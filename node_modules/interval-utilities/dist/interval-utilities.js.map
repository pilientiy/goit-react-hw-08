{"mappings":"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","sources":["packages/interval-utilities/src/index.ts","packages/interval-utilities/src/configure.ts","packages/interval-utilities/src/types.ts"],"sourcesContent":["export * from \"./configure\";\nexport * from \"./types\";\n","import { configure as configurePointUtilities } from \"point-utilities\";\nimport { ComparePoints, Interval, SeparatedInterval, Utilities } from \"./types\";\n\nexport function configure<Point>(\n  comparePoints: ComparePoints<Point>\n): Utilities<Point> {\n  const pointUtils = configurePointUtilities(comparePoints);\n\n  function compare(a: Interval<Point>, b: Interval<Point>): number {\n    const start = pointUtils.compare(a[0], b[0]);\n    const end = pointUtils.compare(a[1], b[1]);\n    return start === 0 ? end : start;\n  }\n\n  function contains(a: Interval<Point>, b: Interval<Point>): boolean {\n    return (\n      pointUtils.lessThanOrEqualTo(a[0], b[0]) &&\n      pointUtils.greaterThanOrEqualTo(a[1], b[1])\n    );\n  }\n\n  function equals(a: Interval<Point>, b: Interval<Point>): boolean {\n    return pointUtils.equals(a[0], b[0]) && pointUtils.equals(a[1], b[1]);\n  }\n\n  function greaterThan(a: Interval<Point>, b: Interval<Point>): boolean {\n    if (pointUtils.greaterThan(a[0], b[0])) {\n      return true;\n    } else if (pointUtils.equals(a[0], b[0])) {\n      return pointUtils.greaterThan(a[1], b[1]);\n    } else {\n      return false;\n    }\n  }\n\n  function greaterThanOrEqualTo(\n    a: Interval<Point>,\n    b: Interval<Point>\n  ): boolean {\n    return !lessThan(a, b);\n  }\n\n  function intersects(a: Interval<Point>, b: Interval<Point>): boolean {\n    return (\n      pointUtils.greaterThanOrEqualTo(a[1], b[0]) &&\n      pointUtils.greaterThanOrEqualTo(b[1], a[0])\n    );\n  }\n\n  function lessThan(a: Interval<Point>, b: Interval<Point>): boolean {\n    if (pointUtils.lessThan(a[0], b[0])) {\n      return true;\n    } else if (pointUtils.equals(a[0], b[0])) {\n      return pointUtils.lessThan(a[1], b[1]);\n    } else {\n      return false;\n    }\n  }\n\n  function lessThanOrEqualTo(a: Interval<Point>, b: Interval<Point>): boolean {\n    return !greaterThan(a, b);\n  }\n\n  function merge(a: Interval<Point>, b: Interval<Point>): Interval<Point>[] {\n    if (contains(a, b)) {\n      return [a];\n    } else if (contains(b, a)) {\n      return [b];\n    } else if (!intersects(a, b)) {\n      return pointUtils.lessThan(a[0], b[0]) ? [a, b] : [b, a];\n    } else {\n      if (pointUtils.lessThan(a[0], b[0])) {\n        return [[a[0], b[1]]];\n      } else {\n        return [[b[0], a[1]]];\n      }\n    }\n  }\n\n  function mergeAll(...sortedRanges: Interval<Point>[]): Interval<Point>[] {\n    if (sortedRanges.length === 0) {\n      return [];\n    } else if (sortedRanges.length === 1) {\n      return sortedRanges;\n    }\n\n    const merged: Interval<Point>[] = [];\n\n    let prevRange: Interval<Point> = sortedRanges[0];\n    let currentRange: Interval<Point> | null = null;\n\n    for (let index = 1; index < sortedRanges.length; index++) {\n      currentRange = sortedRanges[index];\n\n      const tempMerged = merge(prevRange, currentRange);\n      prevRange = tempMerged.pop();\n      merged.push(...tempMerged);\n    }\n\n    merged.push(prevRange);\n\n    return merged;\n  }\n\n  function separate(\n    a: Interval<Point>,\n    b: Interval<Point>\n  ): SeparatedInterval<Point> {\n    const separated: SeparatedInterval<Point> = {\n      a: [],\n      ab: [],\n      b: [],\n    };\n\n    if (equals(a, b)) {\n      separated.ab.push(a);\n    } else if (!intersects(a, b)) {\n      separated.a.push(a);\n      separated.b.push(b);\n    } else {\n      const [a0, a1] = a;\n      const [b0, b1] = b;\n\n      if (pointUtils.lessThan(a0, b0)) {\n        separated.a.push([a0, b0]);\n      } else if (pointUtils.greaterThan(a0, b0)) {\n        separated.b.push([b0, a0]);\n      }\n\n      if (pointUtils.lessThan(a0, b0)) {\n        separated.ab.push([b0, pointUtils.lessThan(a1, b1) ? a1 : b1]);\n      } else {\n        separated.ab.push([a0, pointUtils.lessThan(a1, b1) ? a1 : b1]);\n      }\n\n      if (pointUtils.lessThan(a1, b1)) {\n        separated.b.push([a1, b1]);\n      } else if (pointUtils.greaterThan(a1, b1)) {\n        separated.a.push([b1, a1]);\n      }\n    }\n\n    return separated;\n  }\n\n  function separateAll(\n    a: Interval<Point>[],\n    b: Interval<Point>[]\n  ): SeparatedInterval<Point> {\n    const separated: SeparatedInterval<Point> = {\n      a: [],\n      ab: [],\n      b: [],\n    };\n\n    let currentA: Interval<Point> | null = a[0] ?? null;\n    let currentB: Interval<Point> | null = b[0] ?? null;\n\n    let indexA = 0;\n    let indexB = 0;\n\n    while (currentA !== null && currentB !== null) {\n      const separatedLoop = separate(currentA, currentB);\n\n      // It's always okay to push all overlapping ranges\n      separated.ab.push(...separatedLoop.ab);\n\n      // If the ends of the current range align, we can push all excluded ranges\n      // Else we should keep the last range for whichever comes last\n      // because it might overlap with the next range in the other set\n      if (pointUtils.equals(currentA[1], currentB[1])) {\n        separated.b.push(...separatedLoop.b);\n        separated.a.push(...separatedLoop.a);\n\n        currentA = a[++indexA] ?? null;\n        currentB = b[++indexB] ?? null;\n      } else if (pointUtils.greaterThan(currentA[1], currentB[1])) {\n        currentA = separatedLoop.a.pop();\n\n        separated.b.push(...separatedLoop.b);\n        separated.a.push(...separatedLoop.a);\n\n        currentB = b[++indexB] ?? null;\n      } else {\n        currentB = separatedLoop.b.pop();\n\n        separated.b.push(...separatedLoop.b);\n        separated.a.push(...separatedLoop.a);\n\n        currentA = a[++indexA] ?? null;\n      }\n    }\n\n    while (currentA !== null) {\n      separated.a.push(currentA);\n\n      currentA = a[++indexA] ?? null;\n    }\n\n    while (currentB !== null) {\n      separated.b.push(currentB);\n\n      currentB = b[++indexB] ?? null;\n    }\n\n    return separated;\n  }\n\n  function sort(...ranges: Interval<Point>[]): Interval<Point>[] {\n    return ranges.sort(compare);\n  }\n\n  return {\n    compare,\n    contains,\n    equals,\n    greaterThan,\n    greaterThanOrEqualTo,\n    intersects,\n    lessThan,\n    lessThanOrEqualTo,\n    merge,\n    mergeAll,\n    separate,\n    separateAll,\n    sort,\n  };\n}\n","import type { ComparePoints as ExternalComparePoints } from \"point-utilities\";\n\nexport type ComparePoints<Point> = ExternalComparePoints<Point>;\n\nexport type Interval<Point> = [start: Point, end: Point];\n\nexport type SeparatedInterval<Point> = {\n  a: Interval<Point>[];\n  ab: Interval<Point>[];\n  b: Interval<Point>[];\n};\n\nexport type Utilities<Point> = {\n  compare(a: Interval<Point>, b: Interval<Point>): number;\n  contains(a: Interval<Point>, b: Interval<Point>): boolean;\n  equals(a: Interval<Point>, b: Interval<Point>): boolean;\n  greaterThan(a: Interval<Point>, b: Interval<Point>): boolean;\n  greaterThanOrEqualTo(a: Interval<Point>, b: Interval<Point>): boolean;\n  intersects(a: Interval<Point>, b: Interval<Point>): boolean;\n  lessThan(a: Interval<Point>, b: Interval<Point>): boolean;\n  lessThanOrEqualTo(a: Interval<Point>, b: Interval<Point>): boolean;\n  merge(a: Interval<Point>, b: Interval<Point>): Interval<Point>[];\n  mergeAll(...ranges: Interval<Point>[]): Interval<Point>[];\n  sort(...ranges: Interval<Point>[]): Interval<Point>[];\n  separate(a: Interval<Point>, b: Interval<Point>): SeparatedInterval<Point>;\n  separateAll(\n    a: Interval<Point>[],\n    b: Interval<Point>[]\n  ): SeparatedInterval<Point>;\n};\n"],"names":[],"version":3,"file":"interval-utilities.js.map"}