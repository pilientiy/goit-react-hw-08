import {configure as $2fHMs$configure} from "point-utilities";

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $cb7464d261ec59cd$exports = {};

$parcel$export($cb7464d261ec59cd$exports, "configure", () => $cb7464d261ec59cd$export$8d21e34596265fa2);

function $cb7464d261ec59cd$export$8d21e34596265fa2(comparePoints) {
    const pointUtils = (0, $2fHMs$configure)(comparePoints);
    function compare(a, b) {
        const start = pointUtils.compare(a[0], b[0]);
        const end = pointUtils.compare(a[1], b[1]);
        return start === 0 ? end : start;
    }
    function contains(a, b) {
        return pointUtils.lessThanOrEqualTo(a[0], b[0]) && pointUtils.greaterThanOrEqualTo(a[1], b[1]);
    }
    function equals(a, b) {
        return pointUtils.equals(a[0], b[0]) && pointUtils.equals(a[1], b[1]);
    }
    function greaterThan(a, b) {
        if (pointUtils.greaterThan(a[0], b[0])) return true;
        else if (pointUtils.equals(a[0], b[0])) return pointUtils.greaterThan(a[1], b[1]);
        else return false;
    }
    function greaterThanOrEqualTo(a, b) {
        return !lessThan(a, b);
    }
    function intersects(a, b) {
        return pointUtils.greaterThanOrEqualTo(a[1], b[0]) && pointUtils.greaterThanOrEqualTo(b[1], a[0]);
    }
    function lessThan(a, b) {
        if (pointUtils.lessThan(a[0], b[0])) return true;
        else if (pointUtils.equals(a[0], b[0])) return pointUtils.lessThan(a[1], b[1]);
        else return false;
    }
    function lessThanOrEqualTo(a, b) {
        return !greaterThan(a, b);
    }
    function merge(a, b) {
        if (contains(a, b)) return [
            a
        ];
        else if (contains(b, a)) return [
            b
        ];
        else if (!intersects(a, b)) return pointUtils.lessThan(a[0], b[0]) ? [
            a,
            b
        ] : [
            b,
            a
        ];
        else {
            if (pointUtils.lessThan(a[0], b[0])) return [
                [
                    a[0],
                    b[1]
                ]
            ];
            else return [
                [
                    b[0],
                    a[1]
                ]
            ];
        }
    }
    function mergeAll(...sortedRanges) {
        if (sortedRanges.length === 0) return [];
        else if (sortedRanges.length === 1) return sortedRanges;
        const merged = [];
        let prevRange = sortedRanges[0];
        let currentRange = null;
        for(let index = 1; index < sortedRanges.length; index++){
            currentRange = sortedRanges[index];
            const tempMerged = merge(prevRange, currentRange);
            prevRange = tempMerged.pop();
            merged.push(...tempMerged);
        }
        merged.push(prevRange);
        return merged;
    }
    function separate(a, b) {
        const separated = {
            a: [],
            ab: [],
            b: []
        };
        if (equals(a, b)) separated.ab.push(a);
        else if (!intersects(a, b)) {
            separated.a.push(a);
            separated.b.push(b);
        } else {
            const [a0, a1] = a;
            const [b0, b1] = b;
            if (pointUtils.lessThan(a0, b0)) separated.a.push([
                a0,
                b0
            ]);
            else if (pointUtils.greaterThan(a0, b0)) separated.b.push([
                b0,
                a0
            ]);
            if (pointUtils.lessThan(a0, b0)) separated.ab.push([
                b0,
                pointUtils.lessThan(a1, b1) ? a1 : b1
            ]);
            else separated.ab.push([
                a0,
                pointUtils.lessThan(a1, b1) ? a1 : b1
            ]);
            if (pointUtils.lessThan(a1, b1)) separated.b.push([
                a1,
                b1
            ]);
            else if (pointUtils.greaterThan(a1, b1)) separated.a.push([
                b1,
                a1
            ]);
        }
        return separated;
    }
    function separateAll(a, b) {
        const separated = {
            a: [],
            ab: [],
            b: []
        };
        var _a_;
        let currentA = (_a_ = a[0]) !== null && _a_ !== void 0 ? _a_ : null;
        var _b_;
        let currentB = (_b_ = b[0]) !== null && _b_ !== void 0 ? _b_ : null;
        let indexA = 0;
        let indexB = 0;
        while(currentA !== null && currentB !== null){
            const separatedLoop = separate(currentA, currentB);
            // It's always okay to push all overlapping ranges
            separated.ab.push(...separatedLoop.ab);
            // If the ends of the current range align, we can push all excluded ranges
            // Else we should keep the last range for whichever comes last
            // because it might overlap with the next range in the other set
            if (pointUtils.equals(currentA[1], currentB[1])) {
                separated.b.push(...separatedLoop.b);
                separated.a.push(...separatedLoop.a);
                var _a_1;
                currentA = (_a_1 = a[++indexA]) !== null && _a_1 !== void 0 ? _a_1 : null;
                var _b_1;
                currentB = (_b_1 = b[++indexB]) !== null && _b_1 !== void 0 ? _b_1 : null;
            } else if (pointUtils.greaterThan(currentA[1], currentB[1])) {
                currentA = separatedLoop.a.pop();
                separated.b.push(...separatedLoop.b);
                separated.a.push(...separatedLoop.a);
                var _b_2;
                currentB = (_b_2 = b[++indexB]) !== null && _b_2 !== void 0 ? _b_2 : null;
            } else {
                currentB = separatedLoop.b.pop();
                separated.b.push(...separatedLoop.b);
                separated.a.push(...separatedLoop.a);
                var _a_2;
                currentA = (_a_2 = a[++indexA]) !== null && _a_2 !== void 0 ? _a_2 : null;
            }
        }
        while(currentA !== null){
            separated.a.push(currentA);
            var _a_3;
            currentA = (_a_3 = a[++indexA]) !== null && _a_3 !== void 0 ? _a_3 : null;
        }
        while(currentB !== null){
            separated.b.push(currentB);
            var _b_3;
            currentB = (_b_3 = b[++indexB]) !== null && _b_3 !== void 0 ? _b_3 : null;
        }
        return separated;
    }
    function sort(...ranges) {
        return ranges.sort(compare);
    }
    return {
        compare: compare,
        contains: contains,
        equals: equals,
        greaterThan: greaterThan,
        greaterThanOrEqualTo: greaterThanOrEqualTo,
        intersects: intersects,
        lessThan: lessThan,
        lessThanOrEqualTo: lessThanOrEqualTo,
        merge: merge,
        mergeAll: mergeAll,
        separate: separate,
        separateAll: separateAll,
        sort: sort
    };
}


var $f1c36345d8730ee8$exports = {};




export {$cb7464d261ec59cd$export$8d21e34596265fa2 as configure};
//# sourceMappingURL=interval-utilities.module.js.map
