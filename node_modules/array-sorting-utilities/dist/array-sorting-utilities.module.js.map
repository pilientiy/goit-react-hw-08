{"mappings":";;;;;;ACEO,SAAS,0CACd,aAAmC,EACjB;IAClB,SAAS,KAAK,WAAoB,EAAE,UAAiB,EAAgB;QACnE,MAAM,QAAQ,UAAU,aAAa,YAAY,IAAI;QACrD,IAAI,SAAS,GACX,OAAO,WAAW,CAAC,MAAM;aAEzB,OAAO,IAAI;IAEf;IAEA,0CAA0C;IAC1C,qGAAqG;IACrG,SAAS,UACP,WAAoB,EACpB,UAAiB,EACjB,aAAa,IAAI,EACT;QACR,IAAI,WAAW;QACf,IAAI,YAAY,YAAY,MAAM,GAAG;QACrC,IAAI,cAAc;QAElB,MAAO,YAAY,UAAW;YAC5B,cAAc,AAAC,WAAW,cAAe;YAEzC,MAAM,cAAc,WAAW,CAAC,YAAY;YAC5C,MAAM,QAAQ,cAAc,YAAY;YACxC,IAAI,UAAU,GACZ,OAAO;iBACF,IAAI,QAAQ,GACjB,WAAW,cAAc;iBAEzB,YAAY,cAAc;QAE9B;QAEA,IAAI,YACF,OAAO;aACF;YACL,OAAQ,YAAY,MAAM;gBACxB,KAAK;oBACH,OAAO;gBACT,KAAK;oBACH,OAAO;YACX;YAEA,MAAM,QAAQ,cAAc,YAAY,WAAW,CAAC,YAAY;YAChE,IAAI,UAAU,GACZ,OAAO;iBACF;gBACL,IAAI,WAAW;gBACf,IAAI,YAAY;gBAEhB,IAAI,QAAQ,GACV,YAAY,KAAK,GAAG,CAAC,cAAc,GAAG,YAAY,MAAM,GAAG;qBAE3D,WAAW,KAAK,GAAG,CAAC,GAAG,cAAc;gBAGvC,OAAO,KAAK,GAAG,CAAC,cAAc,YAAY,WAAW,CAAC,SAAS,KAC7D,KAAK,GAAG,CAAC,cAAc,YAAY,WAAW,CAAC,UAAU,KACvD,WACA,SAAS;YACf,CAAC;QACH,CAAC;IACH;IAEA,SAAS,gBAAgB,WAAoB,EAAE,IAAW,EAAU;QAClE,IAAI,WAAW;QACf,IAAI,YAAY,YAAY,MAAM;QAClC,MAAO,WAAW,UAAW;YAC3B,IAAI,cAAc,AAAC,WAAW,cAAe;YAC7C,MAAM,cAAc,WAAW,CAAC,YAAY;YAC5C,IAAI,cAAc,MAAM,eAAe,GACrC,WAAW,cAAc;iBAEzB,YAAY;QAEhB;QAEA,OAAO;IACT;IAEA,SAAS,OAAO,WAAoB,EAAE,IAAW,EAAW;QAC1D,MAAM,gBAAgB,gBAAgB,aAAa;QAEnD,YAAY,MAAM,CAAC,eAAe,GAAG;QAErC,OAAO;IACT;IAEA,OAAO;cACL;mBACA;yBACA;gBACA;IACF;AACF;;ADpGA;;","sources":["packages/array-sorting-utilities/src/index.ts","packages/array-sorting-utilities/src/configure.ts","packages/array-sorting-utilities/src/types.ts"],"sourcesContent":["export * from \"./configure\";\nexport * from \"./types\";\n","import { CompareValues, Utilities } from \"./types\";\n\nexport function configure<Value>(\n  compareValues: CompareValues<Value>\n): Utilities<Value> {\n  function find(sortedItems: Value[], targetItem: Value): Value | null {\n    const index = findIndex(sortedItems, targetItem, true);\n    if (index >= 0) {\n      return sortedItems[index];\n    } else {\n      return null;\n    }\n  }\n\n  // Note that for non-exact matches to work\n  // the comparison function should return more fine-grained delta values than the typical -1, 0, or 1.\n  function findIndex(\n    sortedItems: Value[],\n    targetItem: Value,\n    exactMatch = true\n  ): number {\n    let lowIndex = 0;\n    let highIndex = sortedItems.length - 1;\n    let middleIndex = -1;\n\n    while (lowIndex <= highIndex) {\n      middleIndex = (lowIndex + highIndex) >>> 1;\n\n      const currentItem = sortedItems[middleIndex];\n      const value = compareValues(targetItem, currentItem);\n      if (value === 0) {\n        return middleIndex;\n      } else if (value > 0) {\n        lowIndex = middleIndex + 1;\n      } else {\n        highIndex = middleIndex - 1;\n      }\n    }\n\n    if (exactMatch) {\n      return -1;\n    } else {\n      switch (sortedItems.length) {\n        case 0:\n          return -1;\n        case 1:\n          return 0;\n      }\n\n      const value = compareValues(targetItem, sortedItems[middleIndex]);\n      if (value === 0) {\n        return middleIndex;\n      } else {\n        let lowIndex = middleIndex;\n        let highIndex = middleIndex;\n\n        if (value > 0) {\n          highIndex = Math.min(middleIndex + 1, sortedItems.length - 1);\n        } else {\n          lowIndex = Math.max(0, middleIndex - 1);\n        }\n\n        return Math.abs(compareValues(targetItem, sortedItems[lowIndex])) <\n          Math.abs(compareValues(targetItem, sortedItems[highIndex]))\n          ? lowIndex\n          : highIndex;\n      }\n    }\n  }\n\n  function findInsertIndex(sortedItems: Value[], item: Value): number {\n    let lowIndex = 0;\n    let highIndex = sortedItems.length;\n    while (lowIndex < highIndex) {\n      let middleIndex = (lowIndex + highIndex) >>> 1;\n      const currentItem = sortedItems[middleIndex];\n      if (compareValues(item, currentItem) > 0) {\n        lowIndex = middleIndex + 1;\n      } else {\n        highIndex = middleIndex;\n      }\n    }\n\n    return lowIndex;\n  }\n\n  function insert(sortedItems: Value[], item: Value): Value[] {\n    const insertAtIndex = findInsertIndex(sortedItems, item);\n\n    sortedItems.splice(insertAtIndex, 0, item);\n\n    return sortedItems;\n  }\n\n  return {\n    find,\n    findIndex,\n    findInsertIndex,\n    insert,\n  };\n}\n","export type CompareValues<Point> = (a: Point, b: Point) => number;\n\nexport type Utilities<Value> = {\n  find(sortedItems: Value[], targetItem: Value): Value | null;\n  findIndex(\n    sortedItems: Value[],\n    targetItem: Value,\n    exactMatch?: boolean\n  ): number;\n  findInsertIndex(sortedItems: Value[], item: Value): number;\n  insert(sortedItems: Value[], item: Value): Value[];\n};\n"],"names":[],"version":3,"file":"array-sorting-utilities.module.js.map"}