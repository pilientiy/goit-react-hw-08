function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $9bd0e34f61113b03$exports = {};

$parcel$export($9bd0e34f61113b03$exports, "configure", () => $9bd0e34f61113b03$export$8d21e34596265fa2);
function $9bd0e34f61113b03$export$8d21e34596265fa2(compareValues) {
    function find(sortedItems, targetItem) {
        const index = findIndex(sortedItems, targetItem, true);
        if (index >= 0) return sortedItems[index];
        else return null;
    }
    // Note that for non-exact matches to work
    // the comparison function should return more fine-grained delta values than the typical -1, 0, or 1.
    function findIndex(sortedItems, targetItem, exactMatch = true) {
        let lowIndex = 0;
        let highIndex = sortedItems.length - 1;
        let middleIndex = -1;
        while(lowIndex <= highIndex){
            middleIndex = lowIndex + highIndex >>> 1;
            const currentItem = sortedItems[middleIndex];
            const value = compareValues(targetItem, currentItem);
            if (value === 0) return middleIndex;
            else if (value > 0) lowIndex = middleIndex + 1;
            else highIndex = middleIndex - 1;
        }
        if (exactMatch) return -1;
        else {
            switch(sortedItems.length){
                case 0:
                    return -1;
                case 1:
                    return 0;
            }
            const value = compareValues(targetItem, sortedItems[middleIndex]);
            if (value === 0) return middleIndex;
            else {
                let lowIndex = middleIndex;
                let highIndex = middleIndex;
                if (value > 0) highIndex = Math.min(middleIndex + 1, sortedItems.length - 1);
                else lowIndex = Math.max(0, middleIndex - 1);
                return Math.abs(compareValues(targetItem, sortedItems[lowIndex])) < Math.abs(compareValues(targetItem, sortedItems[highIndex])) ? lowIndex : highIndex;
            }
        }
    }
    function findInsertIndex(sortedItems, item) {
        let lowIndex = 0;
        let highIndex = sortedItems.length;
        while(lowIndex < highIndex){
            let middleIndex = lowIndex + highIndex >>> 1;
            const currentItem = sortedItems[middleIndex];
            if (compareValues(item, currentItem) > 0) lowIndex = middleIndex + 1;
            else highIndex = middleIndex;
        }
        return lowIndex;
    }
    function insert(sortedItems, item) {
        const insertAtIndex = findInsertIndex(sortedItems, item);
        sortedItems.splice(insertAtIndex, 0, item);
        return sortedItems;
    }
    return {
        find: find,
        findIndex: findIndex,
        findInsertIndex: findInsertIndex,
        insert: insert
    };
}


var $6498986854e81fa2$exports = {};


$parcel$exportWildcard(module.exports, $9bd0e34f61113b03$exports);
$parcel$exportWildcard(module.exports, $6498986854e81fa2$exports);


//# sourceMappingURL=array-sorting-utilities.js.map
